Tasks:
	2. ROI Calculator
		- Vanishing Point
		- Edge-Density

	5. Hyperparameter Tuning
		- Best params for both preprocessing and regression

	6. Batch Processing
		- Separate class that handles batch processing (e.g., making multiple instances of CannyLaneDetector() and iterating through them to perform lane detection)

	9. Auto-calc best resize for both mosaic and inset view
		- Instead of fixed param for cv2.resize, identify method for dynamic calculation based on users window size

	10. Finish RegressionJudge()
		- Convert instances from dict of running sum to a list for each metric calculated for each lane
		- Add a __str__() function for the class so that when is printed the avg metrics are printed with the best, worst, and random sample frame metrics are printed 

	11. Identify classification mechanism for lane lines drawn
		- What do the lines do?
		- How are they indicators of actions a driver should take?
		- What is the capacity of the lines to drive action or inform understanding?

	12. BEV Transform / Inverse
		- Identify more robust mechanism for calculation dest. pts. Current approach is very finicky and user-input dependent.
		- Identify best place for BEV Transform to occur (e.g., before thresholding, after feature extraction, etc.)

	14. Benchmark / Profiling
		- Identify potential bottlenecks and evaluate runtime
		- Compare runtime between models, methods (i.e., Canny w/ BEV, Canny w/ out BEV, Hough w/ BEV, Hough w/ out BEV, and all with RANSAC, OLS, Sliding RANSAC, etc.)

			